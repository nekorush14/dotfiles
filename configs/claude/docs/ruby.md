# Rule of programming for Ruby and Rails

## 1. 基本方針 (General Principles)

### Why

コードベース全体の一貫性を保ち、可読性と保守性を最大化するため。RubyとRailsのコミュニティで確立された標準に従うことは、新しい開発者のオンボーディングを容易にし、バグの発生を減少させます。

### What

- **準拠:** [Ruby Style Guide](https://github.com/rubocop-hq/ruby-style-guide) および [Rails Style Guide](https://github.com/rubocop-hq/rails-style-guide) に最大限準拠してください。
- **可読性:** 他の開発者が読んで理解しやすい、明確で簡潔なコードを記述してください。複雑なロジックにはコメントを追加しますが、コード自体が自己説明的であることを目指してください。
- **DRY (Don't Repeat Yourself):** 繰り返しを避け、共通のロジックはメソッドやモジュール（Concernなど）に適切に抽出してください。
- **YAGNI (You Ain't Gonna Need It):** 現在必要とされていない機能や過剰な抽象化を実装しないでください。

## 2. Ruby コーディング規約 (Ruby Coding Conventions)

### Why

Rubyの文法とイディオムを一貫した方法で使用するため。これにより、コードの予測可能性が高まり、レビューが容易になります。

### What

- **命名:** 変数とメソッド名は`snake_case`、クラスとモジュール名は`CamelCase`を使用してください。
- **メソッド:** 1メソッドあたりの行数を適切に保ち（理想的には10行以下）、単一責任の原則（SRP）に従ってください。
- **文字列:** 文字列の連結よりも式展開 (`#{}`) を優先してください。不変の文字列にはシングルクォート (`'`) を、式展開やエスケープシーケンスが必要な場合はダブルクォート (`"`) を使用してください。
- **Guard Clause:** `if`や`unless`のネストを避けるため、早期リターン（Guard Clause）を積極的に使用してください。
- **コレクション:** `map`, `select`, `reject`, `reduce` などの高階関数を適切に使用し、`each` での煩雑なロジック構築を避けてください。

## 3. Rails ベストプラクティス (Rails Best Practices)

### Why

RailsのMVCアーキテクチャの利点を最大限に活かし、「Fat Model, Skinny Controller」の原則を維持するため。責務を明確に分離することで、コードのテスト容易性と再利用性を高めます。

### What

#### 3.1. Controllers (コントローラー)

- **責務:** コントローラーは「リクエストの受け取り」「適切なビジネスロジック（ModelやService Object）の呼び出し」「レスポンス（ViewのレンダリングやJSONの返却）の決定」のみに責任を持ちます。
- **ロジックの排除:** 複雑なビジネスロジックや、複数のモデルにまたがる操作をコントローラーに直接記述しないでください。
- **Strong Parameters:** `params` の受け取りには常にStrong Parametersを使用し、マスアサインメント脆弱性を防いでください。
- **`before_action`:** 共通のセットアップ（例: `@model = Model.find(params[:id])`）には `before_action` を活用してください。

#### 3.2. Models (モデル / Active Record)

- **責務:** モデル（Active Record）は、データ永続化、バリデーション、アソシエーション、およびそのモデル固有の単純なビジネスロジックに責任を持ちます。
- **Fat Model対策:** モデルが肥大化し始めた場合（目安として500行以上、または複数の関心事が混在する場合）、以下のパターンを検討してください。
  - **Service Object (サービスオブジェクト):** 複数のモデルにまたがる操作や、複雑なビジネスプロセス（例: ユーザー登録と同時にメール送信、決済処理）を実行します。
  - **Form Object (フォームオブジェクト):** 複雑なフォーム入力（例: 複数ステップのフォーム、1つのフォームで複数のモデルを更新）のバリデーションと永続化を扱います。
  - **Query Object (クエリオブジェクト):** 複雑なActive Recordクエリをカプセル化し、再利用可能にします。
  - **Presenter / Decorator:** Viewで必要なロジック（表示用のフォーマットなど）をモデルから分離します。
- **N+1問題:** `includes` や `joins` を適切に使用し、N+1クエリを絶対に避けてください。コードレビューの際は常にログを確認してください。
- **スコープ:** 再利用可能なクエリは、`scope` として定義してください。
- **バリデーション:** バリデーションはモデル層に一元化してください。

#### 3.3. Views (ビュー)

- **ロジックの排除:** View（ERB, Slim, Hamlなど）には、表示のための最小限のロジック（ループや条件分岐）のみを記述してください。
- **ヘルパー:** 複雑な表示ロジックやデータ整形は、ヘルパーメソッドまたは上述のPresenter/Decoratorパターンを使用してください。

#### 3.4. ルーティング (Routing)

- **`resources`:** 可能な限り `resources` (または `resource`) を使用し、RESTfulなルーティングを維持してください。
- **ネスト:** ルーティングのネストは1階層までを原則とし、それ以上深くなる場合は `shallow: true` を検討してください。

## 4. テスト (Testing - RSpec)

### Why

コードの品質とリグレッション（意図しない変更によるバグ）の防止を保証するため。テストは、リファクタリングを安全に行うためのセーフティネットです。

### What

- **カバレッジ:** 単純なCRUDだけでなく、ビジネスロジックの境界値や異常系（バリデーションエラーなど）を網羅するテストを記述してください。
- **RSpecの記法:**
  - `context`（条件分岐）と `describe`（テスト対象）を適切に使い分けてください。
  - `let` や `let!` を使用してテストデータをセットアップし、`before` ブロックでのインスタンス変数（`@user`など）の使用は最小限にしてください。
  - `subject` を適切に定義してください。
- **FactoryBot:** テストデータの作成にはFactoryBotを使用してください。
- **テストの種類:**
  - **Model Spec:** バリデーション、メソッド、スコープをテストします。
  - **Request Spec (Integration Test):** エンドポイントへのリクエストからレスポンスまで（HTTPステータスコード、リダイレクト、テンプレートの描画）をテストします。（Controller Specよりも推奨されます）
  - **System Spec (E2E Test):** ユーザーの操作（Capybaraを使用）をシミュレートし、JavaScriptを含む実際のブラウザ動作をテストします。

## 5. セキュリティ (Security)

### Why

アプリケーションとユーザーデータを脆弱性から保護するため。セキュリティは設計の初期段階から組み込まれるべきです。

### What

- **SQLインジェクション:** Active Recordのプレースホルダ (`Model.where("name = ?", params[:name])`) やハッシュ構文 (`Model.where(name: params[:name])`) を常に使用し、文字列展開でクエリを構築しないでください。
- **XSS (クロスサイトスクリプティング):** Viewでの `raw` や `html_safe` の使用は最小限にし、必要な場合は `sanitize` を併用してください。
- **マスアサインメント:** Strong Parametersを徹底してください。
- **機密情報:** APIキー、パスワード、秘密鍵などをコード（特にGitリポジトリ）にハードコードしないでください。`Rails.application.credentials` や環境変数を使用してください。

## 6. パフォーマンス (Performance)

### Why

ユーザー体験を向上させ、サーバーリソースを効率的に使用するため。

### What

- **N+1問題の回避:** (3.2.節参照) `bullet` などのGemを使用して開発環境でN+1を検知してください。
- **DBインデックス:** 頻繁に `where` 句で使用されるカラム、または `order` で使用されるカラムには適切にインデックスを追加してください。
- **バックグラウンドジョブ:** 時間のかかる処理（メール送信、外部API呼び出し、重い計算）は、SidekiqやActive Jobを使用して非同期（バックグラウンド）で実行してください。
- **キャッシュ:** 適切な箇所（例: 変更頻度の低いデータ）でRailsのキャッシュ（Fragment Cache, Low-Level Cache）を活用してください。

## 7. AIへの指示 (Instructions for Claude)

### Why

AIが提供するコードの品質と適合性を高め、開発プロセスを効率化するため。

### What

- **コード生成:** 新しいコードの生成を依頼する際は、上記のすべてのルール（特にStyle Guide、N+1回避、テスト）を考慮してください。
- **リファクタリング:**
  - リファクタリングを依頼する際は、まず「可読性の向上」「パフォーマンスの改善」「責務の分離（Service Objectへの抽出など）」といった目的を明確にしてください。
  - 既存のロジックを変更する場合は、その理由と改善点を説明してください。
- **テストコード:** 機能コードの生成を依頼した場合、可能であれば対応するRSpecのテストコード（特にModel SpecまたはRequest Spec）も同時に生成してください。
